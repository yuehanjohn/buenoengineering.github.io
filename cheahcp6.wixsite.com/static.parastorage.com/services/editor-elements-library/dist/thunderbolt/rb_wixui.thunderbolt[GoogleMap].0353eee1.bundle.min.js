! function(e, t) {
    "object" == typeof exports && "object" == typeof module ? module.exports = t(require("react")) : "function" == typeof define && define.amd ? define("rb_wixui.thunderbolt[GoogleMap]", ["react"], t) : "object" == typeof exports ? exports["rb_wixui.thunderbolt[GoogleMap]"] = t(require("react")) : e["rb_wixui.thunderbolt[GoogleMap]"] = t(e.React)
}("undefined" != typeof self ? self : this, (function(e) {
    return function() {
        var t = {
                5329: function(t) {
                    "use strict";
                    t.exports = e
                },
                448: function(e) {
                    function t() {
                        return e.exports = t = Object.assign ? Object.assign.bind() : function(e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var n = arguments[t];
                                for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o])
                            }
                            return e
                        }, e.exports.__esModule = !0, e.exports.default = e.exports, t.apply(this, arguments)
                    }
                    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports
                }
            },
            n = {};

        function o(e) {
            var r = n[e];
            if (void 0 !== r) return r.exports;
            var a = n[e] = {
                exports: {}
            };
            return t[e](a, a.exports, o), a.exports
        }
        o.n = function(e) {
            var t = e && e.__esModule ? function() {
                return e.default
            } : function() {
                return e
            };
            return o.d(t, {
                a: t
            }), t
        }, o.d = function(e, t) {
            for (var n in t) o.o(t, n) && !o.o(e, n) && Object.defineProperty(e, n, {
                enumerable: !0,
                get: t[n]
            })
        }, o.o = function(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }, o.r = function(e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        }, o.p = "https://static.parastorage.com/services/editor-elements-library/dist/thunderbolt/";
        var r = {};
        return function() {
            "use strict";
            o.r(r), o.d(r, {
                components: function() {
                    return K
                }
            });
            var e = o(448),
                t = o.n(e),
                n = o(5329);

            function a(e) {
                var t, n, o = "";
                if ("string" == typeof e || "number" == typeof e) o += e;
                else if ("object" == typeof e)
                    if (Array.isArray(e))
                        for (t = 0; t < e.length; t++) e[t] && (n = a(e[t])) && (o && (o += " "), o += n);
                    else
                        for (t in e) e[t] && (o && (o += " "), o += t);
                return o
            }
            var i = function() {
                for (var e, t, n = 0, o = ""; n < arguments.length;)(e = arguments[n++]) && (t = a(e)) && (o && (o += " "), o += t);
                return o
            };
            const s = () => "undefined" != typeof window,
                l = e => Object.entries(e).reduce(((e, [t, n]) => (t.includes("data-") && (e[t] = n), e)), {});
            const u = (...e) => e.map((e => e ? `wixui-${e}` : "")).join(" ");
            var c = {
                root: "google-map"
            };
            const d = e => e.replace(/([A-Z])/g, (e => `-${e.toLowerCase()}`)),
                p = (((e, t, n = []) => {
                    e.reduce(((e, t) => ({ ...e,
                        [t]: !0
                    })), {}), n.length
                })(["experiments"], (e => {
                    let {
                        experiments: t
                    } = e;
                    return t["specs.thunderbolt.shouldExportCurrentConsentPolicy"] ? "WithConsentWrapper" : void 0
                })), e => ({
                    consentPolicy: e.currentConsentPolicy,
                    openSettingModal: e.openSettingModal
                }));

            function f() {
                const e = n.useRef([]);
                return [n.useCallback((() => new Promise((t => e.current.push(t)))), []), n.useCallback((t => {
                    e.current.forEach((e => e(t))), e.current.length = 0
                }), [])]
            }
            const g = (e, t) => {
                    if (e || t) return t ? {
                        path: e,
                        fillColor: t,
                        strokeColor: t,
                        fillOpacity: 1,
                        scale: .5
                    } : (e => {
                        if (e && e.endsWith(".webp")) try {
                            const t = e.match(/media\/[^/]+/)[0].split(".")[1];
                            e = e.replace(/.webp$/, "." + t)
                        } catch (e) {}
                        return e
                    })(e)
                },
                m = (e, t) => e.map((e => ({ ...e,
                    icon: g(e.pinIcon, e.pinColor) || t && g(t.pinIcon, null == t ? void 0 : t.pinColor)
                })));
            var v = "load",
                y = "message",
                h = "SET_INITIAL_LOCATIONS",
                M = "SET_CENTER",
                E = "CENTER_UPDATED",
                C = "SET_ZOOM",
                S = "ZOOM_UPDATED",
                b = "MARKER_CLICKED",
                w = "MAP_CLICKED",
                O = "GET_MARKERS",
                _ = "MARKERS",
                N = "FIT_BOUNDS",
                k = "MAP_IDLE",
                x = "OPEN_INFO_WINDOW",
                I = "TILES_LOADED",
                L = "SET_MARKER_ICON",
                R = "SET_MARKER_ICON_FINISHED",
                D = "SET_DIRECTION";
            const P = ["iw", "ar", "ur", "fa"];

            function j(e, t, o) {
                let {
                    mapData: r,
                    language: a,
                    isEditorMode: i
                } = t, {
                    onUpdateZoom: l,
                    onUpdateCenter: u,
                    onMarkerClicked: c,
                    onMapClicked: d
                } = o;
                const p = (0, n.useRef)([]),
                    g = (0, n.useRef)(null),
                    j = (0, n.useMemo)((() => {
                        var e, t, n, o;
                        return void 0 !== r.defaultLocation ? {
                            pinIcon: null != (e = null == (t = r.locations[r.defaultLocation]) ? void 0 : t.pinIcon) ? e : "",
                            pinColor: null != (n = null == (o = r.locations[r.defaultLocation]) ? void 0 : o.pinColor) ? n : ""
                        } : void 0
                    }), [r.defaultLocation, r.locations]),
                    [A, T] = f(),
                    [U, W] = f(),
                    [G, J] = f(),
                    [F, K] = f(),
                    [Z, z] = f(),
                    [V, B] = f(),
                    [H, $] = f(),
                    [q, Q] = (0, n.useState)(!1),
                    X = (e, t) => {
                        const n = g.current;
                        return m(n || e, t)
                    },
                    Y = (0, n.useMemo)((() => ({ ...r,
                        locations: X(r.locations, j)
                    })), [r, j]),
                    ee = function(e, t) {
                        void 0 === t && (t = null);
                        const o = (0, n.useRef)(t);
                        return (0, n.useEffect)((() => {
                            o.current = e
                        }), [e]), o.current
                    }(Y),
                    te = {
                        [E]: e => null == u ? void 0 : u(e),
                        [S]: e => null == l ? void 0 : l({
                            zoom: e
                        }),
                        [b]: e => null == c ? void 0 : c({
                            type: "markerClicked",
                            ...e
                        }),
                        [w]: e => {
                            let {
                                longitude: t,
                                latitude: n,
                                ...o
                            } = e;
                            return null == d ? void 0 : d({
                                type: "mapClicked",
                                location: {
                                    longitude: t,
                                    latitude: n
                                },
                                ...o
                            })
                        },
                        [_]: e => T(e),
                        [k]: () => {
                            const e = p.current.shift();
                            null == e || e()
                        },
                        [I]: () => {
                            q || Q(!0)
                        },
                        [R]: () => $()
                    },
                    ne = {
                        [v]: e => {
                            let {
                                _sendMessage: t
                            } = e;
                            t({
                                type: h,
                                data: JSON.stringify({ ...r,
                                    locations: X(r.locations)
                                })
                            }, {
                                forceSend: !0
                            }), t({
                                type: D,
                                data: JSON.stringify({
                                    direction: P.includes(a) ? "rtl" : "ltr"
                                })
                            })
                        },
                        [y]: e => {
                            let {
                                event: t
                            } = e;
                            if ("string" == typeof t.payload) {
                                var n;
                                const {
                                    type: e,
                                    data: o
                                } = JSON.parse(t.payload);
                                null == (n = te[e]) || n.call(te, o)
                            }
                        }
                    },
                    [oe, re] = function(e) {
                        let {
                            reducer: t = (() => ({})),
                            iframeLoaded: o
                        } = e;
                        const r = (0, n.useRef)([]),
                            a = (0, n.useRef)(void 0),
                            i = (0, n.useRef)(void 0),
                            l = (0, n.useRef)(void 0),
                            u = (0, n.useCallback)(((e, t) => {
                                if (a.current && o || null != t && t.forceSend) {
                                    var n;
                                    const t = null == (n = a.current) ? void 0 : n.contentWindow;
                                    return void(null == t || t.postMessage(e, "*"))
                                }
                                if (!a.current || !i.current || !1 === o) return void r.current.push(e);
                                const s = a.current.contentWindow;
                                null == s || s.postMessage(e, "*")
                            }), [o]),
                            c = (0, n.useCallback)((() => {
                                0 !== r.current.length && !1 !== o && (r.current.forEach((e => u(e))), r.current = [])
                            }), [u, o]),
                            d = (0, n.useCallback)((e => {
                                if (l.current && (l.current(), l.current = void 0), !e) return;
                                const n = () => {
                                    i.current = !0, c(), t({
                                        type: "load"
                                    }, u)
                                };
                                e.addEventListener("load", n), a.current = e, l.current = () => {
                                    e.removeEventListener("load", n)
                                }
                            }), [t, u, c]);
                        return (0, n.useEffect)((() => {
                            o && c()
                        }), [o, c]), (0, n.useEffect)((() => {
                            if (!s()) return;
                            const e = e => {
                                var n;
                                e.source && e.source !== (null == (n = a.current) ? void 0 : n.contentWindow) || t({
                                    type: "message",
                                    payload: e.data
                                }, u)
                            };
                            return window.addEventListener("message", e), () => {
                                window.removeEventListener("message", e)
                            }
                        }), [t, u]), [d, u]
                    }({
                        reducer: (e, t) => {
                            var n;
                            return null == (n = ne[e.type]) ? void 0 : n.call(ne, {
                                event: e,
                                _sendMessage: t
                            })
                        },
                        iframeLoaded: q
                    });
                return (0, n.useImperativeHandle)(e, (() => ({
                    setMapCenter: (e, t) => {
                        const n = U();
                        return re({
                            type: M,
                            data: JSON.stringify({
                                longitude: e,
                                latitude: t
                            })
                        }), p.current.push(W), n
                    },
                    fitBounds: e => {
                        let {
                            north: t,
                            east: n,
                            west: o,
                            south: r
                        } = e;
                        const a = F();
                        return re({
                            type: N,
                            data: JSON.stringify({
                                north: t,
                                east: n,
                                west: o,
                                south: r
                            })
                        }), p.current.push(K), a
                    },
                    setMarkerIcon: e => {
                        let {
                            locations: t,
                            coordinates: n,
                            iconOptions: o
                        } = e;
                        const r = H();
                        return g.current = t, re({
                            type: L,
                            data: JSON.stringify({ ...n,
                                iconOptions: o
                            })
                        }), r
                    },
                    setMapZoom: e => {
                        const t = G();
                        return re({
                            type: C,
                            data: e
                        }), p.current.push(J), t
                    },
                    getVisibleMarkers: () => {
                        const e = A();
                        return re({
                            type: O
                        }), e
                    },
                    openInfoWindow: e => {
                        if (!Y.showDirectionsLink) {
                            const t = V();
                            return re({
                                type: x,
                                data: JSON.stringify({
                                    locationIndex: e
                                })
                            }), p.current.push(B), t
                        }
                        return new Promise((e => e()))
                    },
                    setMarkers: (e, t) => {
                        const n = Z();
                        return g.current = e, re(JSON.stringify({ ...Y,
                            locations: m(e, j),
                            openInfoWindow: null == t ? void 0 : t.openInfoWindow
                        })), p.current.push(z), n
                    }
                }))), (0, n.useEffect)((() => {
                    if (!q || !i) return;
                    const e = !!ee && (t = Y.locations, n = ee.locations, t.length === n.length && t.every(((e, t) => {
                        const o = Object.keys(e);
                        return o.length === Object.keys(n[t]).length && o.every((o => "locationLinkAttributes" === o || e[o] === n[t][o]))
                    })));
                    var t, n;
                    re(JSON.stringify({ ...Y,
                        locations: X(Y.locations, j),
                        shouldKeepMarkers: e
                    }))
                }), [Y, re, j, q, ee, i]), [oe]
            }
            var A = {
                GoogleMapSkin: "azCDHJ",
                googleMapSkin: "azCDHJ",
                mapContainer: "UXiAup",
                GoogleMapDefault: "gzNVjA",
                googleMapDefault: "gzNVjA",
                GoogleMapSloppy: "FiDpOP",
                googleMapSloppy: "FiDpOP",
                brd: "vWE6wc",
                one: "dj3FJn",
                two: "W_nooy",
                GoogleMapLiftedShadow: "e4y5ni",
                googleMapLiftedShadow: "e4y5ni",
                shd: "up3Bvs",
                left: "h0JKNn",
                right: "uaUROu"
            };
            const T = {
                GoogleMapLiftedShadow: () => n.createElement(n.Fragment, null, n.createElement("div", {
                    className: i(A.left, A.shd)
                }), n.createElement("div", {
                    className: i(A.right, A.shd)
                })),
                GoogleMapSloppy: () => n.createElement(n.Fragment, null, n.createElement("div", {
                    className: i(A.brd, A.one)
                }), n.createElement("div", {
                    className: i(A.brd, A.two)
                })),
                GoogleMapSkin: () => n.createElement(n.Fragment, null),
                GoogleMapDefault: () => n.createElement(n.Fragment, null)
            };
            var U = o.p + "media/googleMap.ea5928de.html",
                W = o.p + "media/google-map.min.c5cac041.js";
            const G = e => e.replace("https://static.parastorage.com/services/", "https://editor.wix.com/_partials/"),
                J = (e, o) => {
                    const {
                        id: r,
                        className: a,
                        customClassNames: d = [],
                        skin: p,
                        urlQueries: f,
                        mapData: g,
                        translations: m,
                        isConsentPolicyActive: v,
                        onUpdateCenter: y,
                        onUpdateZoom: h,
                        onMarkerClicked: M,
                        onMapClicked: E,
                        onMouseEnter: C,
                        onMouseLeave: S,
                        isDesignerMode: b,
                        isEditorMode: w,
                        language: O
                    } = e, _ = T[p], N = ((e, t) => {
                        const n = t ? G(W) : W,
                            o = new URLSearchParams({
                                googleMapsScriptPath: new URL(n).pathname
                            });
                        return s() && o.append("origin", window.origin), (t ? G(U) : U) + "?" + e + "&" + o
                    })(f, b), [k, x] = n.useState(!1), [I] = j(o, {
                        mapData: g,
                        isEditorMode: w,
                        language: O
                    }, {
                        onUpdateCenter: y,
                        onUpdateZoom: h,
                        onMarkerClicked: M,
                        onMapClicked: E
                    });
                    n.useEffect((() => {
                        x(!0)
                    }), [N]);
                    const L = m.title,
                        R = ((e, t) => e ? {} : t)(v, {
                            id: r,
                            className: i(A[p], A.wixIframe, a, u(c.root, ...d)),
                            ...l(e)
                        });
                    return n.createElement("div", t()({}, R, {
                        tabIndex: 0
                    }), k && n.createElement("wix-iframe", {
                        title: L,
                        "aria-label": L,
                        "data-src": N
                    }, n.createElement(_, null), n.createElement("div", {
                        id: "mapContainer_" + r,
                        onMouseEnter: C,
                        onMouseLeave: S,
                        className: A.mapContainer
                    }, n.createElement("iframe", {
                        ref: I,
                        title: L,
                        "aria-label": L,
                        "data-src": N,
                        width: "100%",
                        height: "100%",
                        frameBorder: "0",
                        scrolling: "no",
                        allowFullScreen: !0
                    }))))
                };
            var F;
            const K = {
                GoogleMap: {
                    component: n.forwardRef(J),
                    controller: (F = e => {
                        let {
                            stateValues: t,
                            mapperProps: n
                        } = e;
                        return { ...n,
                            ...p(t)
                        }
                    }, {
                        useComponentProps: (e, t, n) => {
                            const o = (e => ({ ...e,
                                updateStyles: t => {
                                    const n = Object.entries(t).reduce(((e, [t, n]) => {
                                        return { ...e,
                                            [(o = t, o.startsWith("--") ? t : d(t))]: void 0 === n ? null : n
                                        };
                                        var o
                                    }), {});
                                    e.updateStyles(n)
                                }
                            }))(n);
                            return F({
                                mapperProps: e,
                                stateValues: t,
                                controllerUtils: o
                            })
                        }
                    })
                }
            }
        }(), r
    }()
}));
//# sourceMappingURL=https://static.parastorage.com/services/editor-elements-library/dist/thunderbolt/rb_wixui.thunderbolt[GoogleMap].0353eee1.bundle.min.js.map