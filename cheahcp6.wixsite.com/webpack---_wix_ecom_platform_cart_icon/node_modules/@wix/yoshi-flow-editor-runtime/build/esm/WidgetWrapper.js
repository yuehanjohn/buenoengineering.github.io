var __extends = (this && this.__extends) || (function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({
                    __proto__: []
                }
                instanceof Array && function(d, b) {
                    d.__proto__ = b;
                }) ||
            function(d, b) {
                for (var p in b)
                    if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);

        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function() {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function(s, e) {
    var t = {};
    for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, {
    useMemo,
    useState
} from 'react';
import {
    createCurrencyFormatterWithDefaults,
    formatAddress,
} from '@wix/fe-essentials-viewer-platform/l10n';
import {
    withSentryErrorBoundary,
} from '@wix/native-components-infra';
import memoize from 'lodash/memoize';
import cloneDeep from 'lodash/cloneDeep';
import {
    Translations,
    disabledTranslationsFunction
} from './i18next';
import {
    WithProviders
} from './react/utils';
import {
    ErrorProvider,
    useWidgetErrorContext,
} from './react/ErrorProvider';
import {
    WidgetEnvironment
} from './environment/Widget';
import {
    WidgetEnvironmentConsumer,
    WidgetEnvironmentProvider,
} from './react/EnvironmentProvider';
import {
    SentryProvider
} from './react/Sentry';
import {
    ErrorMonitorProvider
} from './react/ErrorMonitor';
import {
    TpaSettingsProviderWithExperiments
} from './react/WidgetTpaSettingsProviderWithExperiments';
import {
    FlowPropsConsumer
} from './controller/FlowProps/FlowPropsConsumer';
import {
    useEnsureFlowProps
} from './controller/FlowProps/useEnsureFlowProps';
import {
    ModalProvider
} from './react/Modal/ModalContext';
import CurrencyFormatterProvider from './react/CurrencyFormatter/CurrencyFormatterProvider';
import AddressFormatterProvider from './react/AddressFormatter/AddressFormatterProvider';
var useFlowProps = function(props) {
    return useMemo(function() {
        return new FlowPropsConsumer({
            props: props
        });
    }, [props]);
};
var skipErrorBubbling = function(Component) {
    return /** @class */ (function(_super) {
        __extends(class_1, _super);

        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.componentDidCatch = function() {
            return;
        };
        class_1.prototype.render = function() {
            return React.createElement(Component, __assign({}, this.props));
        };
        return class_1;
    }(React.Component));
};
var AppLoadedHandler = /** @class */ (function(_super) {
    __extends(AppLoadedHandler, _super);

    function AppLoadedHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AppLoadedHandler.prototype.componentDidMount = function() {
        if (this.props.onAppLoaded) {
            this.props.host.registerToComponentDidLayout(this.props.onAppLoaded);
        }
    };
    AppLoadedHandler.prototype.render = function() {
        return this.props.children;
    };
    return AppLoadedHandler;
}(React.Component));
// This widget is going to be called inside entry-point wrappers
// Each widget should contain component to wrap name, so here we return a getter instead of component.
export var getWidgetWrapper = function(_a, UserComponent, _b) {
    var initI18n = _a.initI18n,
        withStylesHoc = _a.withStylesHoc,
        createWidgetExperiments = _a.createWidgetExperiments,
        providers = _a.providers;
    var name = _b.name,
        componentId = _b.componentId,
        withErrorBoundary = _b.withErrorBoundary,
        localeDistPath = _b.localeDistPath,
        translationsConfig = _b.translationsConfig,
        sentryConfig = _b.sentryConfig,
        styleHocConfig = _b.styleHocConfig,
        stylesParams = _b.stylesParams,
        customCssVars = _b.customCssVars,
        multilingualDisabled = _b.multilingualDisabled;
    var Widget = function(props) {
        var _a;
        var _widgetError = props.error,
            _widgetErrorId = props.errorId,
            host = props.host,
            widgetProps = __rest(props, ["error", "errorId", "host"]);
        var flowPropsConsumer = useFlowProps(props);
        var panoramaClient = useState(function() {
            return flowPropsConsumer.getPanoramaClient();
        })[0];
        if (flowPropsConsumer.getProp('error') &&
            process.env.NODE_ENV === 'development' &&
            !withErrorBoundary) {
            var controllerError = flowPropsConsumer.getControllerError();
            if (controllerError) {
                throw controllerError.error;
            }
        }
        if (_widgetError &&
            process.env.NODE_ENV === 'development' &&
            !withErrorBoundary) {
            throw _widgetError;
        }
        var _b = providers,
            I18nextProvider = _b.I18nextProvider,
            PureExperimentsProvider = _b.PureExperimentsProvider,
            BILoggerProvider = _b.BILoggerProvider,
            TPAComponentsProvider = _b.TPAComponentsProvider,
            FedopsLoggerProvider = _b.FedopsLoggerProvider,
            PanoramaProvider = _b.PanoramaProvider;
        var biLogger = flowPropsConsumer.getBILogger();
        var environment = new WidgetEnvironment({
            host: host,
            controllerOptions: {
                appDefinitionId: flowPropsConsumer.getProp('appDefinitionId'),
                widgetId: flowPropsConsumer.getProp('widgetId'),
                isSSR: flowPropsConsumer.getProp('isSSR'),
                isRTL: flowPropsConsumer.getProp('isRTL'),
                language: flowPropsConsumer.getProp('language'),
                multilingual: !multilingualDisabled ?
                    (_a = flowPropsConsumer.getProp('multilingual')) !== null && _a !== void 0 ? _a : null :
                    null,
            },
            query: widgetProps.query,
        });
        var experiments = flowPropsConsumer.getProp('experiments');
        var experimentsInstance = useMemo(function() {
            if (!flowPropsConsumer.isHOCEnabled('experiments')) {
                return undefined;
            }
            return createWidgetExperiments({
                experiments: experiments
            });
        }, [experiments]);
        var createCurrencyFormatter = useMemo(function() {
            return createCurrencyFormatterWithDefaults({
                language: environment.language,
            });
        }, [environment.language]);
        var widgetError = useWidgetErrorContext(_widgetError, _widgetErrorId, flowPropsConsumer.getControllerError());
        var availableProviders = [
            function(children) {
                return (React.createElement(TPAComponentsProvider, {
                    value: {
                        mobile: environment.isMobile,
                        rtl: environment.isRTL,
                    }
                }, children));
            },
            function(children) {
                return (React.createElement(ErrorProvider, {
                    value: widgetError
                }, children));
            },
        ];
        if (flowPropsConsumer.isHOCEnabled('bi')) {
            availableProviders.push(function(children) {
                return (React.createElement(BILoggerProvider, {
                    logger: biLogger
                }, children));
            });
        }
        if (flowPropsConsumer.isHOCEnabled('fedops')) {
            availableProviders.push(function(children) {
                return (React.createElement(FedopsLoggerProvider, {
                    value: flowPropsConsumer.getProp('fedopsLogger')
                }, children));
            });
        }
        if (flowPropsConsumer.isHOCEnabled('panoramaClient')) {
            availableProviders.push(function(children) {
                return (React.createElement(PanoramaProvider, {
                    value: panoramaClient
                }, children));
            });
        }
        if (flowPropsConsumer.isHOCEnabled('sentry')) {
            availableProviders.push(function(children) {
                return (React.createElement(SentryProvider, {
                    value: flowPropsConsumer.getProp('sentry')
                }, children));
            });
        }
        if (flowPropsConsumer.isHOCEnabled('errorMonitor')) {
            availableProviders.push(function(children) {
                return (React.createElement(ErrorMonitorProvider, {
                    errorMonitor: flowPropsConsumer.getProp('errorMonitor')
                }, children));
            });
        }
        var language = flowPropsConsumer.getProp('language');
        var translationsValues = flowPropsConsumer.getProp('translations');
        var isTranslationsEnabled = flowPropsConsumer.isHOCEnabled('translations');
        var i18NextInstance = useMemo(function() {
            if (!isTranslationsEnabled) {
                return undefined;
            }
            var translations = new Translations({
                localeDistPath: localeDistPath,
                language: language,
                availableLanguages: translationsConfig === null || translationsConfig === void 0 ? void 0 : translationsConfig.availableLanguages,
                prefix: translationsConfig === null || translationsConfig === void 0 ? void 0 : translationsConfig.prefix,
                initI18n: initI18n,
            });
            translations.init({
                prepopulated: translationsValues,
                useSuspense: false,
                wait: !environment.isSSR,
            });
            return translations.i18n;
        }, [isTranslationsEnabled, language, translationsValues]);
        var t = useMemo(function() {
            return i18NextInstance ?
                i18NextInstance.t.bind(i18NextInstance) :
                disabledTranslationsFunction;
        }, [i18NextInstance]);
        if (flowPropsConsumer.isHOCEnabled('translations')) {
            availableProviders.push(function(children) {
                return (React.createElement(I18nextProvider, {
                    i18n: i18NextInstance
                }, children));
            });
        }
        availableProviders.push(function(children) {
            return (React.createElement(WidgetEnvironmentConsumer, null, function(environment) {
                var _a, _b, _c, _d, _e, _f;
                var _g = environment.isEditor || environment.isEditorX || environment.isADI ?
                    [
                        cloneDeep((_a = host === null || host === void 0 ? void 0 : host.style) === null || _a === void 0 ? void 0 : _a.styleParams),
                        cloneDeep((_b = host === null || host === void 0 ? void 0 : host.style) === null || _b === void 0 ? void 0 : _b.siteColors),
                        cloneDeep((_c = host === null || host === void 0 ? void 0 : host.style) === null || _c === void 0 ? void 0 : _c.siteTextPresets),
                    ] :
                    [
                        (_d = host === null || host === void 0 ? void 0 : host.style) === null || _d === void 0 ? void 0 : _d.styleParams,
                        (_e = host === null || host === void 0 ? void 0 : host.style) === null || _e === void 0 ? void 0 : _e.siteColors,
                        (_f = host === null || host === void 0 ? void 0 : host.style) === null || _f === void 0 ? void 0 : _f.siteTextPresets,
                    ],
                    styleParams = _g[0],
                    siteColors = _g[1],
                    siteTextPresets = _g[2];
                return (React.createElement(TpaSettingsProviderWithExperiments, {
                    isMobile: environment.isMobile,
                    isRTL: environment.isRTL,
                    publicData: flowPropsConsumer.getProp('publicData'),
                    currentStylesGetter: !environment.isSSR ? host.getCurrentStyle : undefined,
                    allStylesGetter: host.getAllStyles,
                    styleParamsPerBreakpointMode: environment.isCssPerBreakpoint,
                    stylesParams: stylesParams !== null && stylesParams !== void 0 ? stylesParams : {},
                    hostStyle: {
                        styleParams: styleParams,
                        siteColors: siteColors,
                        siteTextPresets: siteTextPresets,
                    },
                    dimensions: environment.dimensions,
                    language: (environment.multilingual.isEnabled &&
                            environment.multilingual.currentLanguage) ||
                        undefined,
                    t: t,
                    isEditorX: environment.isEditorX,
                    experimentsDisabled: !flowPropsConsumer.isHOCEnabled('experiments')
                }, children));
            }));
        });
        if (flowPropsConsumer.isHOCEnabled('experiments')) {
            availableProviders.push(function(children) {
                return (React.createElement(PureExperimentsProvider, {
                    experiments: experimentsInstance
                }, children));
            });
        }
        // We want AppLoaderHandler to wrap all other providers;
        availableProviders.push(function(children) {
            return (React.createElement(AppLoadedHandler, {
                    onAppLoaded: flowPropsConsumer.getProp('onAppLoaded'),
                    host: props.host
                },
                React.createElement(ModalProvider, {
                    openModal: flowPropsConsumer.getProp('openModal')
                }, children)));
        });
        availableProviders.push(function(children) {
            return (React.createElement(WidgetEnvironmentProvider, {
                value: environment
            }, children));
        });
        availableProviders.push(function(children) {
            return (React.createElement(CurrencyFormatterProvider, {
                value: createCurrencyFormatter
            }, children));
        });
        availableProviders.push(function(children) {
            return (React.createElement(AddressFormatterProvider, {
                value: formatAddress
            }, children));
        });
        return (React.createElement(WithProviders, {
                providers: availableProviders
            },
            React.createElement(UserComponent, __assign({
                host: host
            }, widgetProps))));
    };
    var shouldWrapWithStyleHoc = styleHocConfig === null || styleHocConfig === void 0 ? void 0 : styleHocConfig.enabled;
    if (!withStylesHoc) {
        throw new Error('withStyles HOC have not been passed, please report this to Yoshi team');
    }
    var WidgetWithStylesComponent = withStylesHoc(Widget, {
        defaults: stylesParams !== null && stylesParams !== void 0 ? stylesParams : undefined,
        customCssVars: customCssVars,
        enableMemoization: typeof WeakMap === 'undefined' || memoize.Cache !== WeakMap,
    });
    var WidgetComponent = shouldWrapWithStyleHoc ?
        function(props) {
            var flowPropsConsumer = useFlowProps(props);
            useEnsureFlowProps(name, flowPropsConsumer);
            // This logic is needed for App settings -> Styles migration and just allows to override style values.
            // It will be removed once we won't have any projects based on app settings solution.
            var stylesProp = flowPropsConsumer.getProp('styles');
            var platformHost = props.host;
            var host = useMemo(function() {
                if (stylesProp) {
                    platformHost.style.styleParams = stylesProp;
                }
                return platformHost;
            }, [platformHost, stylesProp]);
            return (React.createElement(WidgetWithStylesComponent, __assign({}, props, {
                host: host,
                isRTL: flowPropsConsumer.getProp('isRTL'),
                isMobile: flowPropsConsumer.getProp('mobile')
            })));
        } :
        Widget;
    if (sentryConfig) {
        // Update sentry error boundary to set error state and pass it to state here.
        var WrappedWithSentry = function(props) {
            var flowPropsConsumer = useFlowProps(props);
            var isSSR = flowPropsConsumer.getProp('isSSR');
            var isSEO = flowPropsConsumer.getProp('isSEO');
            var Widget = useMemo(function() {
                return withSentryErrorBoundary(WidgetComponent, {
                        dsn: sentryConfig.DSN,
                        config: {
                            environment: 'Viewer',
                        },
                        tags: {
                            componentId: componentId,
                            componentName: name,
                            isSSR: isSSR,
                            isSEO: isSEO,
                        },
                    }, withErrorBoundary ?
                    skipErrorBubbling(WidgetComponent) :
                    WidgetComponent);
            }, [componentId, name, isSSR, isSEO]);
            return React.createElement(Widget, __assign({}, props));
        };
        return WrappedWithSentry;
    }
    return WidgetComponent;
};
//# sourceMappingURL=WidgetWrapper.js.map